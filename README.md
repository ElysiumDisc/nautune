# Nautune

Poseidon's cross-platform Jellyfin music player. Nautune is built with Flutter and complemented by a Swift-based CarPlay plugin so your library follows you across devices and dashboards.

## Highlights
- Deep Sea Purple experience defined in `lib/theme/nautune_theme.dart` and shared across every platform target.
- Linux-first development flow (Lubuntu/Kubuntu) with Codemagic handling iOS builds — no Snap or Android toolchain required to get started.
- Planned Swift CarPlay plugin housed under `plugins/` for tight integration with Jellyfin playback.
- Cross-device sync through GitHub via SSH to keep multiple workstations aligned.
- Seamless Jellyfin login with persistent sessions managed by `lib/app_state.dart`.
- Audio library discovery and selection powered by the custom Jellyfin client (`lib/jellyfin/`) and Deep Sea themed UI screens.
- Album grid view with live Jellyfin artwork (trident placeholder when art is missing) to showcase each library’s collection.
- Curated playlists and recently added feeds cached in-memory for snappy reloads across the session.

## Roadmap
- [x] Integrate Jellyfin authentication and session persistence.
- [x] Filter and select Jellyfin audio libraries.
- [x] Surface albums from the selected Jellyfin library with artwork.
- [x] Fetch playlists and recently added tracks with lightweight caching.
- [x] Build album detail view with track listings and navigation.
- [x] Implement persistent playback state (track position, queue, current track).
- [ ] Implement audio playback with background audio and media controls.
- [ ] Build media catalog browsing (artists, playlists detail views).
- [ ] Wire the Swift CarPlay plugin into the Flutter engine.
- [ ] Build a cohesive now-playing experience and queue management UI.
- [ ] Harden multiplatform builds (Linux, Windows, macOS, iOS, Web).

## Repository Layout
- `lib/` – Flutter application code. `main.dart` boots the app and applies the custom theme defined in `theme/`.
- `lib/app_state.dart` – Central ChangeNotifier handling login state, session restoration, and library selection.
- `lib/jellyfin/` – Client, models, and persistence helpers for Jellyfin (credentials, session store, library fetching, album tracks).
- `lib/screens/` – Nautune UI screens (`login_screen.dart`, `library_screen.dart`, `album_detail_screen.dart`) backing the authentication, library picker, and album browsing flows.
- `lib/models/` – Data models including `playback_state.dart` for persistent playback tracking.
- `lib/services/` – Service layer including `playback_state_store.dart` for saving/loading playback position and queue.
- `assets/` – Images, icons, and future audio assets (empty by default).
- `plugins/` – Home for the Swift CarPlay plugin and other federated platform modules.
- `android`, `ios`, `linux`, `macos`, `windows`, `web` – Platform-specific runners generated by Flutter.
- `test/` – Widget and unit tests (add coverage as features land).
- `analysis_options.yaml` – Static analysis rules (`flutter_lints`).

## Getting Started
1. Install Flutter (stable channel, revision `adc9010`, Dart SDK 3.9). Confirm with `flutter doctor`.
2. Clone the repository over SSH: `git clone git@github.com:<org>/nautune.git`.
3. From the project root, fetch dependencies: `flutter pub get`.
4. Run the Linux desktop build: `flutter run -d linux`. Sign in with your Jellyfin server (URL, username, password), then choose the audio library Nautune should sync with.

> Tip: Development is Linux-only. Keep your environment Snap-free by using the official Flutter tarball or FVM and relying on Codemagic for iOS artifacts.

## Building for Other Platforms
- **iOS**: Builds are produced by Codemagic. Ensure the CarPlay Swift plugin is committed under `plugins/` so CI can bundle it. Refer to Codemagic workflow files (to be added) for signing and provisioning.
- **Windows / macOS**: Use `flutter build windows` or `flutter build macos` on their respective OSes once platform-specific prerequisites are installed.
- **Web**: `flutter run -d chrome` for rapid iteration, `flutter build web` to generate deployable assets.
- **Android**: Currently not a focus; no Android SDK or emulator is required for development.

## Development Guidelines
- Follow Dart/Flutter lints enforced by `analysis_options.yaml`. Run `flutter analyze` before pushing.
- Add unit/widget tests for new features: `flutter test`.
- Keep UI code declarative; centralize styling in `lib/theme/`.
- Maintain Jellyfin integrations inside `lib/jellyfin/`; expose state to widgets through `NautuneAppState`.
- Gate new UI with graceful loading/error states similar to the login and library picker.
- Document complex flows in the codebase with short comments so collaborators ramp up quickly.

## Contributing & Collaboration
- Work on feature branches synced over SSH. Open pull requests against `main` with a short demo or screenshots when UI changes.
- Coordinate multiplatform changes early (e.g., desktop shortcuts, CarPlay hooks) to avoid drift between Flutter and Swift components.
- Use descriptive commit messages and note any Codemagic considerations in PR descriptions.

## Next Steps
1. Integrate an audio engine (e.g., `just_audio` + `audio_service`) for actual playback with background audio support.
2. Wire playback state persistence to save/restore track position when user pauses or app restarts.
3. Build artist and playlist detail views with track listings sourced from Jellyfin.
4. Design the now playing UI with queue management and media controls.
5. Implement background audio service that respects playback state persistence.
6. Draft Codemagic configuration files for automated iOS packaging and CarPlay builds.
